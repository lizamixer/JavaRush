package Other;

public class Yield extends Thread {

    public Yield() {
        this.start();
    }

    public void run() {

        System.out.println(Thread.currentThread().getName() + " уступает свое место другим");
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + " has finished executing.");
    }

    public static void main(String[] args) {
        new Yield();
        new Yield();
        new Yield();
    }
}

/*
Мы последовательно создаем и запускаем три потока — Thread-0, Thread-1 и Thread-2.
Thread-0 запускается первым и сразу уступает место другим. После него запускается Thread-1, и тоже уступает.
После — запускается Thread-2, который тоже уступает.
Больше потоков у нас нет, и после того, как Thread-2 последним уступил свое место, планировщик потоков смотрит:
«Так, новых потоков больше нет, кто у нас там в очереди? Кто уступал свое место последним, перед Thread-2?
Кажется, это был Thread-1? Окей, значит пусть он и выполняется».
Thread-1 выполняет свою работу до конца, после чего планировщик потоков продолжает координацию: «Окей,
Thread-1 выполнился. Есть у нас кто-то еще в очереди?». В очереди есть Thread-0: он уступал свое место сразу до Thread-1.
Теперь дело дошло до него, и он выполняется до конца.
После чего планировщик заканчивает координацию потоков: «Ладно, Thread-2, ты уступил место другим потокам,
они все уже отработали. Ты уступал место последним, так что теперь твоя очередь». После этого отрабатывает
до конца поток Thread-2.

Планировщик потоков, конечно, может запустить потоки в другом порядке (например, 2-1-0 вместо 0-1-2), но сам принцип неизменный.
 */